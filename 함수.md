# int 타입인지 검사
result = isinstance(7, int) 
print(result)

>>> True 
# float 타입인지 검사 
result = isinstance(0.001, float) 
print(result)

>>> True

# str 타입인지 검사 
result = isinstance(333, str) 
print(result)

>>> False

## 리스트 내 타입 검사 
test = [1,2,'3' ,4,5]

신장 트리 
n개의 정점으로 이루어진 무향 그래프에서 n개의 정점과 n-1개의 간선으로 이루어진 트리

최소 신장 트리
무향 가중치 그래프에서 신장 트리를 구성하는 간선들의 가중치의 합이 최소인 신장트리


크루스칼 알고리즘
간선을 하나씩 선택해서 mst를 찾는 알고리즘
1.최초, 모든 간선을 가중치에 따라 오름차순으로 정렬
2.가중치가 가장 낮은 간선부터 선택
3.선택한 간선의 두 정점의 대표자가 다르다면 엣지를 최소 비용 집합에 추가
같다면 사이클이 생성되므로 무시
4.n-1개의 간선이 선택될 때까지 반복

특징
그리디 알고리즘을 활용
간선을 가중치 순으로 정렬하여 처리
disjoint를 사용하여 사이클 형성 방지

장점
희소 그래프에서 효율적
간선 중심 알고리즘
음의 가중치도 처리할 수 있음

단점
간선 정렬이 필요함
동적 그래프에 적용하기 어려움

시간복잡도
O(E log E),O(E log V)

프림 알고리즘
하나의 정점에서 연결된 간선들 중 하나씩 선택하면서 mst를 만들어가는 방식
1.임의 정점을 하나 선택해서 시작
2.우선순위 큐를 사용하여 간선의 가중치가 가장 작은 간선을 선택
3.가장 가중치가 작은 간선을 선택하고, 이 간선이 연결하는 정점이 이미 방문한 정점이 아니라면, 이 간선을 최소 신장 트리에
추가하고, 그 정점을 방문한 것으로 표시
4.우선순위 큐가 빌 때까지 위 과정을 반복

특징
그리디 알고리즘을 활용
각 단계에서 간선 중 가장 가중치가 작은 간선을 선택

장점 
밀집 그래프에서 효율적
정점 중심의 알고리즘

단점
희소 그래프에서 비효율적
음의 가중치를 처리할 수  없음

시간 복잡도
O((V+E) log V)




-------------
# DP

## DP 적용을 위한 2가지 핵심 조건

- **최적 부분 구조(Optimal Substructure)**: 큰 문제의 최적 해답을 그것을 구성하는 작은 문제들의
최적 해답으로부터 구할 수 있는 구조. 즉, 부분 문제의 최적 해가 전체 문제의 최적 해를 보장한다.

- **중복되는 부분 문제(Overlapping Subproblems)**: 큰 문제를 작은 문제로 나누었을 때, 동일한 작은 문제가 여러 번 반복되어 나타나는 성질.
DP는 이 반복되는 문제의 결과를 한 번만 계산 하고 저정(Memoization)하여 재사용함으로써 계산 횟수를 획기적으로 줄입니다.

## 하향식 상향식 차이

- **하향식(메모이제이션)**: 큰 문제에서 시작하여 작은 문제로 재귀 호출을 통해 내려가는 방식입니다. 이 과정에서 한 번  계산된 부분
문제의 결과는 배열 등에 저장해두고, 동일한 문제를 다시 만나면 재계산 없이 저장된 값을 반환합니다. 직관적이고 필요한 부분 문제만 
계산하는 장점이 있으나, 재귀 호출로 인한 오버헤드나 스택 오버플로우의 위험이 있습니다.

- **상향식(테이블화)**: 가장 작은 문제부터 시작하여 문제의 크기를 점차 키워가며 모든 부분 문제의 해답을 순차적으로 계산하여 테이블에 저장하는 방식입니다.
최종적으로 목표 문제의 해답을 구합니다. 반복문을 사용하무로 재귀 오버헤드가 없고, 모든 부분 문제의 해를 알 수 있다는 장점이 있으나, 불필여한 부분 문제까지 계산할 수 있습니다


# 힙

## 힙의 2가지 핵심 속성과 최대/최소 힙의 차이

- **모양 속성(Shape Property)**: 힙은 항상 '완전 이진 트리'의 형태를 유지 해야합니다.
마지막 레벨을 제외하고 모든 레벨이 완전히 채워져 있으며, 마지막 레벨의 노드들은 왼쪽부터 차례대로 채워집니다.
- **힙 속성(Heap Property)**: 모든 부모 노드는 자식 노드와의 대소 관계가 일정해야 합니다.
    - 최대 힙: 부모 노드의 키 값은 항상 자식 노드의 키 값보다 크거나 같습니다. 따라서 루트 노드는 전체 데이터 중 최댓값을 가집니다.
    - 최소 힙: 부모 노드의 키 값은 항상 자식 노드의 키 값보다 작거나 같습니다. 따라서 루트 노드는 전체 데이터 중 최솟값을 가집니다.

## 시간 복잡도와 응용 분야

- **시간 복잡도**: 힙에서의 삽입(insert)과 삭제(delete) 연산은 모두 O(log N)의 시간 복잡도를 가집니다. (N은 힙의 노드 개수)
- **응용 이유(우선순위 큐)**: 우선순위 큐는 가장 우선순위가 높은 데이터를 빠르게 조회하고 제거 할 수 있어야 합니다. 힙은 완전 이진 트리 구조로 인해 높이가 log N에 비례하여
매우 낮게 유지되며, 힙 속성 덕분에 루트 노드에 항상 최댓값(또는 최솟값)이 위치합니다. 따라서 O(1)로 최 우선순위 데이터를 조회하고, O(log N)이라는 매우 빠른 시간
안에 데이터를 삽입하거나 삭제하며 구조를 재조정할 수 있어 우선순위 큐 구현에 가장 효율적인 자료구조입니다.

## 최대 힙의 삽입 및 삭제 과정

- **삽입**
    1. 새로운 데이터를 트리의 마지막 위치(완전 이진 트리를 유지하는 위치)에 추가합니다.
  2. 새로 추가된 노드를 자신의 부모 노드와 비교합니다.
  3. 만약 자식(새 노드)이 부모보다 크면, 둘의 위치를 바꿉니다.
  4. 이 과정을 부모보다 작거나 같아지거나, 루트에 도달할 때까지 반복합니다.

- **삭제**
    1. 루트 노드를 제거하고, 그 자리에 트리의 가장 마지막 노드를 가져옵니다.
  2. 현재 노드를 두 자식 노드 중 더 큰 값을 가진 자식과 비교합니다.
  3. 만약 자식이 현재 노드보다 크면, 둘의 위치를 바꿉니다.
  4. 이 과정을 자식보다 크거나 같아지거나, 리프 노드에 도달할 때까지 반복합니다.

aaaa