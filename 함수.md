# int 타입인지 검사
result = isinstance(7, int) 
print(result)

>>> True 
# float 타입인지 검사 
result = isinstance(0.001, float) 
print(result)

>>> True

# str 타입인지 검사 
result = isinstance(333, str) 
print(result)

>>> False

## 리스트 내 타입 검사 
test = [1,2,'3' ,4,5]

신장 트리 
n개의 정점으로 이루어진 무향 그래프에서 n개의 정점과 n-1개의 간선으로 이루어진 트리

최소 신장 트리
무향 가중치 그래프에서 신장 트리를 구성하는 간선들의 가중치의 합이 최소인 신장트리


크루스칼 알고리즘
간선을 하나씩 선택해서 mst를 찾는 알고리즘
1.최초, 모든 간선을 가중치에 따라 오름차순으로 정렬
2.가중치가 가장 낮은 간선부터 선택
3.선택한 간선의 두 정점의 대표자가 다르다면 엣지를 최소 비용 집합에 추가
같다면 사이클이 생성되므로 무시
4.n-1개의 간선이 선택될 때까지 반복

특징
그리디 알고리즘을 활용
간선을 가중치 순으로 정렬하여 처리
disjoint를 사용하여 사이클 형성 방지

장점
희소 그래프에서 효율적
간선 중심 알고리즘
음의 가중치도 처리할 수 있음

단점
간선 정렬이 필요함
동적 그래프에 적용하기 어려움

시간복잡도
O(E log E),O(E log V)

프림 알고리즘
하나의 정점에서 연결된 간선들 중 하나씩 선택하면서 mst를 만들어가는 방식
1.임의 정점을 하나 선택해서 시작
2.우선순위 큐를 사용하여 간선의 가중치가 가장 작은 간선을 선택
3.가장 가중치가 작은 간선을 선택하고, 이 간선이 연결하는 정점이 이미 방문한 정점이 아니라면, 이 간선을 최소 신장 트리에
추가하고, 그 정점을 방문한 것으로 표시
4.우선순위 큐가 빌 때까지 위 과정을 반복

특징
그리디 알고리즘을 활용
각 단계에서 간선 중 가장 가중치가 작은 간선을 선택

장점 
밀집 그래프에서 효율적
정점 중심의 알고리즘

단점
희소 그래프에서 비효율적
음의 가중치를 처리할 수  없음

시간 복잡도
O((V+E) log V)




-------------

## DP 적용을 위한 2가지 핵심 조건

- **최적 부분 구조(Optimal Substructure)**: 큰 문제의 최적 해답을 그것을 구성하는 작은 문제들의
최적 해답으로부터 구할 수 있는 구조. 즉, 부분 문제의 최적 해가 전체 문제의 최적 해를 보장한다.

- **중복되는 부분 문제(Overlapping Subproblems)**: 큰 문제를 작은 문제로 나누었을 때, 동일한 작은 문제가 여러 번 반복되어 나타나는 성질.
DP는 이 반복되는 문제의 결과를 한 번만 계산 하고 저정(Memoization)하여 재사용함으로써 계산 횟수를 획기적으로 줄입니다.

## 하향식 상향식 차이

- **하향식(메모이제이션)**: 큰 문제에서 시작하여 작은 문제로 재귀 호출을 통해 내려가는 방식입니다. 이 과정에서 한 번  계산된 부분
문제의 결과는 배열 등에 저장해두고, 동일한 문제를 다시 만나면 재계산 없이 저장된 값을 반환합니다. 직관적이고 필요한 부분 문제만 
계산하는 장점이 있으나, 재귀 호출로 인한 오버헤드나 스택 오버플로우의 위험이 있습니다.

- **상향식(테이블화)**: 가장 작은 문제부터 시작하여 문제의 크기를 점차 키워가며 모든 부분 문제의 해답을 순차적으로 계산하여 테이블에 저장하는 방식입니다.
최종적으로 목표 문제의 해답을 구합니다. 반복문을 사용하무로 재귀 오버헤드가 없고, 모든 부분 문제의 해를 알 수 있다는 장점이 있으나, 불필여한 부분 문제까지 계산할 수 있습니다
